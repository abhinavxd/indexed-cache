/* indexed-cache - v0.4.4
* Kailash Nadh. Licensed MIT */
let e=!1;class t{constructor(t){if(e)throw new Error("indexed-cache is already loaded");e=!0,this.opt={tags:["script","img","link"],dbName:"indexed-cache",storeName:"objects",prune:!1,skip:!1,expiry:131400,...t},this.db=null}async init(){this.db||this.opt.skip||await this._initDB(this.opt.dbName,this.opt.storeName).then((e=>{this.db=e})).catch((e=>{console.log("error initializing cache DB. failing over.",e)}))}async load(e){const t=await this._setupElements(e);if(this.db&&0!==t.length&&this.opt.prune){const e=t.map((e=>e.key));this._prune(e)}}deleteKey(e){this.db&&this._store().delete(e)}prune(e){this._prune(e)}clear(){this.db&&this._store().clear()}_initDB(e,t){return new Promise(((r,s)=>{window.indexedDB||s(new Error("indexedDB is not available"));const a=window.indexedDB.open(e);a.onupgradeneeded=e=>{const s=e.target.result;e.target.result.objectStoreNames.contains(t)||(s.createObjectStore(t,{keyPath:"key"}),e.target.transaction.oncomplete=()=>{r(s)})},a.onsuccess=()=>r(a.result),a.onerror=e=>s(e.target.error),setTimeout((()=>{this.db||s(new Error("Opening IndexedbDB timed out"))}),200)}))}async _setupElements(e){const t=[];if(e instanceof NodeList)e=Array.from(e);else if(e instanceof Node)e=[e];else{const t=this.opt.tags.map((e=>`${e}[data-src]:not([data-indexed])`)).join(",");e=document.querySelectorAll(t)}if(Array.prototype.forEach.call(e,(e=>{if("indexed"in e.dataset)return;const r={el:e,key:e.dataset.key||e.dataset.src,src:e.dataset.src,hash:e.dataset.hash||e.dataset.src,isAsync:"SCRIPT"!==e.tagName||e.hasAttribute("async")||e.hasAttribute("defer"),expiry:null,data:{}},s=e.dataset.expiry||this.opt.expiry;s&&(r.expiry=new Date((new Date).getTime()+6e4*parseInt(s))),t.push(r)})),!this.db)return void this._applyElements(t);const r=[];return t.forEach((e=>{e.isAsync?this._getObject(e).then((t=>{this._applyElement(e,t.data.blob)})).catch((t=>{this._applyElement(e)})):r.push(this._getObject(e))})),0===r.length||await function(e){const t=e.map((e=>Promise.resolve(e).then((e=>({status:"fulfilled",value:e})),(e=>({status:"rejected",reason:e})))));return Promise.all(t)}(r).then((e=>{const t=e.reduce(((e,t)=>(e.push({...t.value.obj,data:t.value.data}),e)),[]);this._applyElements(t)})),t}_getObject(e){return new Promise(((t,r)=>{this._getDBblob(e).then((r=>{t({obj:e,data:r})})).catch((r=>{"Error"!==r.toString()&&console.log("error getting cache blob:",r),this._fetchObject(e).then((r=>{t({obj:e,data:r})})).catch((r=>{t({obj:e,data:{key:e.key,hash:e.hash,expiry:e.expiry,blob:null}})}))}))}))}_getDBblob(e){return new Promise(((t,r)=>{try{const s=this._store().get(e.key);s.onsuccess=s=>{const a=s.target.result;if(a&&(!e.hash||a.hash===e.hash))return a.expiry&&new Date>new Date(a.expiry)?(this.deleteKey(a.key),void r(new Error(""))):void t(a);r(new Error(""))},s.onerror=e=>{r(e.target.error)}}catch(e){r(e.target.error)}}))}_fetchObject(e){return new Promise(((t,r)=>{fetch(e.src).then((s=>{s.ok?s.blob().then((s=>{const a={key:e.key,hash:e.hash,expiry:e.expiry,blob:s};try{const e=this._store().put(a);e.onsuccess=()=>t(a),e.onerror=e=>r(e.target.error)}catch(e){r(e)}})):r(new Error(`error fetching asset: ${s.status}`))})).catch((e=>r(e)))}))}_applyElement(e,t){let r=e.src;switch(t&&(r=window.URL.createObjectURL(t)),e.el.tagName){case"SCRIPT":case"IMG":e.el.src=r;break;case"LINK":e.el.href=r}e.el.dataset.indexed=!0}_applyElements(e){e.forEach(((t,r)=>{r>=e.length-1||(t.el.onload=t.el.onerror=()=>{this._applyElement(e[r+1],e[r+1].data.blob)})})),this._applyElement(e[0],e[0].data.blob)}_prune(e){if(!this.db)return;const t=e.reduce(((e,t)=>(e[t]=!0,e)),{});this._store().getAllKeys().onsuccess=e=>{e.target.result.forEach((e=>{e in t||this.deleteKey(e)}))}}_store(){return this.db.transaction(this.opt.storeName,"readwrite").objectStore(this.opt.storeName)}}export{t as default};
